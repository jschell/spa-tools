<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>F1 Race Tracker</title>
  <meta name="description" content="Formula 1 race timing tower with live gaps, intervals, tyre data, and race control feed powered by OpenF1.">
  <!-- Tailwind CSS v3 Play CDN â€” pinned via cdn.tailwindcss.com (v3.x) -->
  <script src="https://cdn.tailwindcss.com"></script>
  <script>tailwind.config = { darkMode: 'class' };</script>
  <style>
    :root {
      --bg-primary:  #0F0F0F;
      --bg-surface:  #1A1A1A;
      --bg-surface2: #242424;
      --text-primary:#F0F0F0;
      --text-muted:  #6B6B6B;
      --green:  #00D964;
      --red:    #E8002D;
      --yellow: #FFD700;
      --blue:   #0067FF;
    }
    html { background: var(--bg-primary); color: var(--text-primary); }
    body { font-family: ui-monospace, 'SFMono-Regular', Menlo, Consolas, monospace; }

    .ty { display:inline-flex; align-items:center; justify-content:center;
          width:1.5rem; height:1.5rem; border-radius:9999px;
          font-size:.65rem; font-weight:700; flex-shrink:0; }
    .ty-SOFT        { background:#E8002D; color:#fff; }
    .ty-MEDIUM      { background:#FFD700; color:#000; }
    .ty-HARD        { background:#E8E8E8; color:#000; }
    .ty-INTERMEDIATE{ background:#39B54A; color:#fff; }
    .ty-WET         { background:#0067FF; color:#fff; }
    .ty-UNKNOWN,.ty-{ background:#444;    color:#aaa; }

    .pos-1 { color:#FFD700; font-weight:800; }
    .pos-2 { color:#C0C0C0; font-weight:700; }
    .pos-3 { color:#CD7F32; font-weight:700; }

    @keyframes blink { 0%,100%{opacity:1} 50%{opacity:.3} }
    .live-dot { animation: blink 1.8s ease-in-out infinite; }

    .rc-red    { border-left:3px solid #E8002D; }
    .rc-yellow { border-left:3px solid #FFD700; }
    .rc-blue   { border-left:3px solid #0067FF; }
    .rc-green  { border-left:3px solid #00D964; }
    .rc-white  { border-left:3px solid #F0F0F0; }
    .rc-none   { border-left:3px solid #333; }

    input[type=range] { accent-color: var(--green); width:100%; }
    .speed-btn { font-size:.7rem; padding:.15rem .5rem; border-radius:.25rem;
                 border:1px solid #333; background:transparent; color:var(--text-muted); cursor:pointer; }
    .speed-btn.active { background:#333; color:var(--text-primary); border-color:#555; }
    .track-badge { font-size:.65rem; font-weight:800; letter-spacing:.06em;
                   padding:.15rem .5rem; border-radius:.3rem; line-height:1.4; }
  </style>
</head>
<body class="min-h-screen p-3">

<p class="text-sm mb-3" style="color:var(--text-muted)">
  <a href="index.html" style="color:var(--text-muted)">&larr; All tools</a>
</p>

<!-- â”€â”€ HEADER â”€â”€ -->
<header class="rounded-lg p-3 mb-3 flex flex-wrap items-center gap-3"
        style="background:var(--bg-surface)">
  <div class="flex items-center gap-2">
    <span id="live-dot" class="inline-block w-2.5 h-2.5 rounded-full"
          style="background:var(--text-muted)"></span>
    <span id="session-label" class="font-bold text-sm tracking-wide">Loadingâ€¦</span>
    <span id="status-badge" class="text-xs font-bold tracking-widest"></span>
    <span id="track-condition-badge" class="track-badge" style="display:none"></span>
  </div>
  <span id="lap-label" class="text-sm" style="color:var(--text-muted)"></span>
  <span class="flex-1"></span>
  <span id="updated-label" class="text-xs" style="color:var(--text-muted)"></span>
</header>

<!-- â”€â”€ REPLAY CONTROLS (hidden unless replay mode) â”€â”€ -->
<div id="replay-bar" style="display:none" class="rounded-lg p-3 mb-3"
     style="background:var(--bg-surface)">
  <div class="flex items-center gap-3 mb-2">
    <span id="replay-elapsed" class="text-xs tabular-nums"
          style="color:var(--text-muted);min-width:4rem;text-align:right">00:00:00</span>
    <input type="range" id="replay-scrubber" min="0" max="1000" value="0">
    <span id="replay-duration" class="text-xs tabular-nums"
          style="color:var(--text-muted);min-width:4rem">00:00:00</span>
  </div>
  <div class="flex items-center gap-2">
    <span class="text-xs" style="color:var(--text-muted)">Speed:</span>
    <button class="speed-btn" data-speed="1"  onclick="setReplaySpeed(1)">1Ã—</button>
    <button class="speed-btn" data-speed="4"  onclick="setReplaySpeed(4)">4Ã—</button>
    <button class="speed-btn" data-speed="16" onclick="setReplaySpeed(16)">16Ã—</button>
    <button class="speed-btn" data-speed="64" onclick="setReplaySpeed(64)">64Ã—</button>
    <span id="replay-status" class="text-xs ml-2" style="color:var(--text-muted)"></span>
  </div>
</div>

<!-- â”€â”€ IDLE PANEL (shown when no active session) â”€â”€ -->
<div id="idle-panel" style="display:none" class="rounded-lg p-6 mb-3 text-center"
     style="background:var(--bg-surface)">
  <p class="text-xs uppercase tracking-widest mb-3" style="color:var(--text-muted)">Next Race</p>
  <h2 id="next-race-name" class="text-xl font-bold mb-1">â€”</h2>
  <p id="next-race-circuit" class="text-sm mb-1" style="color:var(--text-muted)">â€”</p>
  <p id="next-race-date"    class="text-sm mb-4" style="color:var(--text-muted)">â€”</p>
  <p id="countdown" class="text-4xl font-bold tabular-nums mb-6"
     style="color:var(--green); letter-spacing:.05em">â€”</p>

  <div id="last-race-block" style="display:none">
    <p class="text-xs uppercase tracking-widest mb-2" style="color:var(--text-muted)">
      Last Race Result
    </p>
    <div id="last-race-podium" class="flex justify-center gap-6 text-sm"></div>
  </div>

  <p class="text-xs mt-6" style="color:var(--text-muted)">
    Load a past session: append <code>?session=&lt;key&gt;</code> or
    replay it: <code>?replay=&lt;key&gt;&amp;speed=16</code>
  </p>
</div>

<!-- â”€â”€ MAIN CONTENT â”€â”€ -->
<div id="main-content" style="display:none" class="flex flex-col lg:flex-row gap-3">

  <!-- Timing Tower -->
  <section class="flex-1 rounded-lg overflow-hidden" style="background:var(--bg-surface)">
    <div class="flex items-center justify-between px-3 py-2"
         style="border-bottom:1px solid #2a2a2a">
      <span class="text-xs font-bold tracking-widest uppercase"
            style="color:var(--text-muted)">Timing Tower</span>
      <button id="copy-btn" onclick="copyStandings()" class="speed-btn">Copy</button>
    </div>
    <div class="grid text-xs px-2 py-1" style="color:var(--text-muted);
         grid-template-columns:2rem 3.5rem 2rem 2.2rem 3rem 5.5rem 5.5rem 6rem 2rem">
      <span class="text-center">P</span>
      <span>Driver</span>
      <span class="text-center">Tyre</span>
      <span class="text-right">Age</span>
      <span class="text-right">Lap</span>
      <span class="text-right">Gap</span>
      <span class="text-right">Int</span>
      <span class="text-right">Last Lap</span>
      <span class="text-center">Pit</span>
    </div>
    <div id="timing-note" class="text-xs px-3 py-1.5" style="display:none;color:var(--text-muted);background:var(--bg-surface2)"></div>
    <div id="timing-rows"></div>
  </section>

  <!-- Race Control -->
  <aside class="w-full lg:w-72 rounded-lg overflow-hidden" style="background:var(--bg-surface)">
    <div class="px-3 py-2 flex items-center justify-between" style="border-bottom:1px solid #2a2a2a">
      <span class="text-xs font-bold tracking-widest uppercase"
            style="color:var(--text-muted)">Race Control</span>
      <div class="flex gap-1">
        <button class="speed-btn rc-filter active" data-filter="all"   onclick="setRcFilter('all')">All</button>
        <button class="speed-btn rc-filter"        data-filter="flags" onclick="setRcFilter('flags')">Flags</button>
        <button class="speed-btn rc-filter"        data-filter="sc"    onclick="setRcFilter('sc')">SC</button>
        <button class="speed-btn rc-filter"        data-filter="drs"   onclick="setRcFilter('drs')">DRS</button>
      </div>
    </div>
    <div id="rc-feed" class="text-xs p-2 space-y-1"
         style="max-height:32rem; overflow-y:auto;"></div>
  </aside>
</div>

<!-- â”€â”€ WEATHER FOOTER â”€â”€ -->
<footer class="mt-3 rounded-lg px-3 py-2 flex flex-wrap gap-4 text-xs"
        style="background:var(--bg-surface)">
  <span id="wx-track"    style="color:var(--text-muted)">Track â€”</span>
  <span id="wx-air"      style="color:var(--text-muted)">Air â€”</span>
  <span id="wx-humidity" style="color:var(--text-muted)">Humidity â€”</span>
  <span id="wx-wind"     style="color:var(--text-muted)">Wind â€”</span>
  <span id="wx-rain"     style="color:var(--text-muted)">Rain â€”</span>
  <span class="flex-1 text-right">
    <a href="https://github.com/jschell/spa-tools/blob/main/f1-race-tracker.html"
       style="color:var(--text-muted)">View source</a>
  </span>
</footer>

<script>
// â”€â”€ Constants â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const BASE_URL = 'https://api.openf1.org/v1';
const POLL_CFG = {
  intervals:    { ms: 10000 },
  position:     { ms: 10000 },
  race_control: { ms: 10000 },
  pit:          { ms: 20000 },
  stints:       { ms: 30000, noIncremental: true },
  laps:         { ms: 30000 },
  weather:      { ms: 60000 },
};

// â”€â”€ localStorage TTL cache â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function lsSet(key, data, ttlMs) {
  try { localStorage.setItem(key, JSON.stringify({ data, expiresAt: Date.now() + ttlMs })); }
  catch (_) {}
}
function lsGet(key) {
  try {
    const raw = localStorage.getItem(key);
    if (!raw) return null;
    const { data, expiresAt } = JSON.parse(raw);
    if (Date.now() > expiresAt) { localStorage.removeItem(key); return null; }
    return data;
  } catch (_) { return null; }
}

// â”€â”€ Race state â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const rs = {
  session: { key: null, name: '', circuit: '', status: 'IDLE', totalLaps: null },
  drivers: {},
  stints:  {},
  raceControl: [],
  weather: {},
  lapMax: 0,
  lastUpdated: {},
  errors: {},
  broadcastOffset: 0,
};

// â”€â”€ UI state â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let rcFilter = 'all';

// â”€â”€ URL params â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let _replayKey = null, _replaySpeed = 1;

function readUrlParams() {
  const p = new URLSearchParams(location.search);
  if (p.has('replay')) {
    _replayKey   = parseInt(p.get('replay'));
    _replaySpeed = parseInt(p.get('speed') || 16);
    rs.session.status = 'REPLAY';
  } else if (p.has('session')) {
    rs.session.key = parseInt(p.get('session'));
  }
  if (p.has('offset')) rs.broadcastOffset = parseInt(p.get('offset'));
}

function persistUrl() {
  const p = new URLSearchParams();
  if (rs.session.key) p.set('session', rs.session.key);
  if (rs.broadcastOffset) p.set('offset', rs.broadcastOffset);
  history.replaceState(null, '', '?' + p.toString());
}

// â”€â”€ Fetch helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async function apiFetch(path, params = {}) {
  const url = new URL(`${BASE_URL}/${path}`);
  for (const [k, v] of Object.entries(params)) url.searchParams.set(k, v);
  const maxAttempts = 4;
  for (let attempt = 0; attempt < maxAttempts; attempt++) {
    if (attempt > 0) await new Promise(r => setTimeout(r, 1000 * attempt)); // 1s, 2s, 3s
    const res = await fetch(url.toString());
    if ((res.status === 429 || res.status === 503) && attempt < maxAttempts - 1) continue;
    if (!res.ok) {
      let detail;
      try { detail = (await res.json()).detail; } catch (_) {}
      throw new Error(`${res.status}: ${detail || 'unknown error'}`);
    }
    return res.json();
  }
}

async function fetchIncremental(endpoint, extraParams = {}) {
  const cfg  = POLL_CFG[endpoint] || {};
  const params = { session_key: rs.session.key, ...extraParams };
  const lastTs = rs.lastUpdated[endpoint];
  if (lastTs && !cfg.noIncremental) params['date>='] = lastTs;

  const url = new URL(`${BASE_URL}/${endpoint}`);
  for (const [k, v] of Object.entries(params)) url.searchParams.set(k, v);
  const cacheKey = 'f1_' + url.toString();
  const cached = lsGet(cacheKey);
  if (cached) return cached;

  const res = await fetch(url.toString());
  if (!res.ok) throw new Error(`${res.status} on ${endpoint}`);
  const data = await res.json();
  if (data.length > 0 && data[data.length - 1].date) {
    rs.lastUpdated[endpoint] = data[data.length - 1].date;
  }
  lsSet(cacheKey, data, 8000);
  return data;
}

// â”€â”€ Merge functions â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function escapeHtml(s) {
  return String(s ?? '').replace(/&/g,'&amp;').replace(/</g,'&lt;')
                        .replace(/>/g,'&gt;').replace(/"/g,'&quot;');
}

function mergeDrivers(data) {
  for (const d of data) {
    const n = d.driver_number;
    rs.drivers[n] = {
      number: n,
      acronym: d.name_acronym || '???',
      fullName: d.full_name || '',
      teamName: d.team_name || '',
      teamColour: d.team_colour ? '#' + d.team_colour : '#555',
      position: null, gapToLeader: null, interval: null,
      lastLapTime: null, currentLap: null,
      tyre: { compound: '', age: 0, stintNumber: 0, lapStart: 1 },
      lastPitLap: null, pitCount: 0, _pitLaps: new Set(),
      status: 'RACING',
    };
  }
}

function mergeIntervals(data) {
  const latest = {};
  for (const r of data) {
    if (!latest[r.driver_number] || r.date > latest[r.driver_number].date)
      latest[r.driver_number] = r;
  }
  for (const [n, r] of Object.entries(latest)) {
    const d = rs.drivers[n];
    if (!d) continue;
    if (r.gap_to_leader !== null && r.gap_to_leader !== undefined) d.gapToLeader = r.gap_to_leader;
    if (r.interval      !== null && r.interval      !== undefined) d.interval    = r.interval;
    if (r.position) d.position = r.position;
  }
}

function mergePositions(data) {
  const latest = {};
  for (const r of data) {
    if (!latest[r.driver_number] || r.date > latest[r.driver_number].date)
      latest[r.driver_number] = r;
  }
  for (const [n, r] of Object.entries(latest)) {
    const d = rs.drivers[n];
    if (d) d.position = r.position;
  }
}

function mergeLaps(data) {
  const latest = {};
  for (const r of data) {
    if (!latest[r.driver_number] || r.lap_number > latest[r.driver_number].lap_number)
      latest[r.driver_number] = r;
    if (r.lap_number > rs.lapMax) rs.lapMax = r.lap_number;
  }
  for (const [n, r] of Object.entries(latest)) {
    const d = rs.drivers[n];
    if (d) { d.currentLap = r.lap_number; d.lastLapTime = r.lap_duration; }
  }
}

function mergeStints(data) {
  for (const r of data) {
    const n = r.driver_number;
    const prev = rs.stints[n];
    if (!prev || r.stint_number >= prev.stint_number) rs.stints[n] = r;
  }
  for (const [n, s] of Object.entries(rs.stints)) {
    const d = rs.drivers[n];
    if (!d) continue;
    if (s.compound) d.tyre.compound = s.compound;
    d.tyre.stintNumber = s.stint_number || 0;
    d.tyre.lapStart = s.lap_start || 1;
  }
}

function mergePits(data) {
  for (const r of data) {
    const d = rs.drivers[r.driver_number];
    if (!d) continue;
    if (!d._pitLaps) d._pitLaps = new Set();
    if (!d._pitLaps.has(r.lap_number)) {
      d._pitLaps.add(r.lap_number);
      d.pitCount = d._pitLaps.size;
    }
    if (!d.lastPitLap || r.lap_number > d.lastPitLap) d.lastPitLap = r.lap_number;
  }
}

function mergeRaceControl(data) {
  for (const r of data) {
    rs.raceControl.push({
      date: r.date, category: r.category || '', flag: r.flag || '',
      message: r.message || '', driverNumber: r.driver_number, lapNumber: r.lap_number,
    });
  }
  rs.raceControl.sort((a, b) => b.date.localeCompare(a.date));
  rs.raceControl = rs.raceControl.slice(0, 150);
  // Extract total laps from CHEQUERED message
  for (const m of rs.raceControl) {
    if (m.message && m.message.toUpperCase().includes('CHEQUERED') && m.lapNumber) {
      rs.session.totalLaps = m.lapNumber;
    }
  }
}

function mergeWeather(data) {
  if (!data.length) return;
  const r = data[data.length - 1];
  rs.weather = { trackTemp: r.track_temperature, airTemp: r.air_temperature,
                 humidity: r.humidity, windSpeed: r.wind_speed, rainfall: r.rainfall };
}

// â”€â”€ Render helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function fmtLapTime(secs) {
  if (!secs) return 'â€”';
  return `${Math.floor(secs / 60)}:${(secs % 60).toFixed(3).padStart(6, '0')}`;
}
function fmtGap(val) {
  if (val === null || val === undefined) return 'LEADER';
  if (typeof val === 'string') return val;
  if (val >= 60) return `+${Math.floor(val / 60)} LAP`;
  return `+${parseFloat(val).toFixed(3)}`;
}
function tyreClass(c) { return `ty ty-${(c || '').toUpperCase()}`; }
function tyreLabel(c) {
  return { SOFT:'S', MEDIUM:'M', HARD:'H', INTERMEDIATE:'I', WET:'W' }[(c||'').toUpperCase()] || '?';
}
function posClass(p) { return p===1?'pos-1':p===2?'pos-2':p===3?'pos-3':''; }
function rcBorderClass(msg) {
  const t = (msg.flag + ' ' + msg.message).toUpperCase();
  if (t.includes('RED FLAG')||t.includes('RED_FLAG')) return 'rc-red';
  if (t.includes('YELLOW')||t.includes('SC DEPLOYED')||t.includes('VSC')) return 'rc-yellow';
  if (t.includes('SAFETY CAR')||t.includes('VIRTUAL')) return 'rc-blue';
  if (t.includes('GREEN')||t.includes('CLEAR')) return 'rc-green';
  if (t.includes('BLACK AND WHITE')||t.includes('PENALTY')) return 'rc-white';
  return 'rc-none';
}
function fmtDuration(ms) {
  const s = Math.floor(ms / 1000);
  return `${String(Math.floor(s/3600)).padStart(2,'0')}:${String(Math.floor((s%3600)/60)).padStart(2,'0')}:${String(s%60).padStart(2,'0')}`;
}

// Returns the current track condition derived from the most recent
// flag/safety-car race control message, or null if unknown/normal.
function currentTrackStatus() {
  for (const m of rs.raceControl) {   // newest-first
    const flag = (m.flag    || '').toUpperCase();
    const msg  = (m.message || '').toUpperCase();
    if (flag === 'CHEQUERED' || msg.includes('CHEQUERED'))
      return { label: 'FINISH', color: '#000', bg: '#FFD700' };
    if (flag === 'RED' || msg.includes('RED FLAG') || msg.includes('RED_FLAG'))
      return { label: 'RED FLAG', color: '#fff', bg: '#E8002D' };
    if (msg.includes('VIRTUAL SAFETY CAR DEPLOYED') || msg.includes('VSC DEPLOYED'))
      return { label: 'VSC', color: '#000', bg: '#FFA500' };
    if (msg.includes('VIRTUAL SAFETY CAR ENDING') || msg.includes('VSC ENDING'))
      return { label: 'VSC ENDING', color: '#000', bg: '#FFD700' };
    if (msg.includes('SAFETY CAR DEPLOYED') || msg.includes('SC DEPLOYED'))
      return { label: 'SAFETY CAR', color: '#000', bg: '#FFA500' };
    if (msg.includes('SAFETY CAR IN THIS LAP') || msg.includes('SAFETY CAR ENDING'))
      return { label: 'SC ENDING', color: '#000', bg: '#FFD700' };
    if (flag === 'DOUBLE YELLOW') return { label: 'DBL YELLOW', color: '#000', bg: '#FFD700' };
    if (flag === 'YELLOW')        return { label: 'YELLOW',     color: '#000', bg: '#FFD700' };
    if (flag === 'GREEN' && !msg.includes('PIT EXIT') && !msg.includes('PIT LANE'))
      return { label: 'GREEN', color: '#000', bg: '#00D964' };
    if (msg.includes('TRACK CLEAR') || msg.includes('ALL CLEAR'))
      return { label: 'GREEN', color: '#000', bg: '#00D964' };
    // Skip DRS, penalties, investigations â€” keep scanning for a status event
    if (msg.includes('DRS') || msg.includes('PENALTY') || msg.includes('INVESTIGATION') ||
        msg.includes('INCIDENT') || msg.includes('STEWARDS') || flag === 'BLACK AND WHITE')
      continue;
  }
  return null;
}

function setRcFilter(f) {
  rcFilter = f;
  document.querySelectorAll('.rc-filter').forEach(btn =>
    btn.classList.toggle('active', btn.dataset.filter === f));
  renderRaceControl();
}

// â”€â”€ Render components â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function renderStatusIndicator() {
  const cfgs = {
    LIVE:     ['#00D964', true,  'LIVE'],
    FINISHED: ['#FFD700', false, 'FINISHED'],
    IDLE:     ['#6B6B6B', false, 'IDLE'],
    ERROR:    ['#E8002D', false, 'ERROR'],
    REPLAY:   ['#0067FF', true,  'REPLAY'],
  };
  const [color, pulse, label] = cfgs[rs.session.status] || cfgs.IDLE;
  const dot = document.getElementById('live-dot');
  dot.style.background = color;
  dot.classList.toggle('live-dot', pulse);
  const badge = document.getElementById('status-badge');
  badge.textContent = label;
  badge.style.color = color;
}

function renderHeader() {
  const parts = [rs.session.name, rs.session.circuit].filter(Boolean);
  document.getElementById('session-label').textContent =
    parts.join(' Â· ') || (rs.session.key ? `Session ${rs.session.key}` : 'F1 Race Tracker');

  // Lap counter: actual > estimated > nothing
  const totalLaps = rs.session.totalLaps;
  let lapText = '';
  if (rs.lapMax) {
    lapText = totalLaps ? `Lap ${rs.lapMax} / ${totalLaps}` : `Lap ${rs.lapMax}`;
  } else if (totalLaps && rs.session.status === 'REPLAY' && replay.durationMs) {
    // Only estimate once numeric gaps exist â€” that's the proxy for race start.
    // Before that, the session window includes pre-race activities and the
    // elapsed/duration ratio would produce misleadingly high lap numbers.
    const raceUnderway = Object.values(rs.drivers).some(d => typeof d.gapToLeader === 'number');
    if (raceUnderway) {
      const est = Math.round(totalLaps * replay.elapsedMs / replay.durationMs);
      lapText = `~Lap ${Math.max(1, est)} / ${totalLaps}`;
    }
  }
  document.getElementById('lap-label').textContent = lapText;

  // Track condition badge
  const tcb = document.getElementById('track-condition-badge');
  const tc  = currentTrackStatus();
  if (tc) {
    tcb.textContent        = tc.label;
    tcb.style.background   = tc.bg;
    tcb.style.color        = tc.color;
    tcb.style.display      = '';
  } else {
    tcb.style.display = 'none';
  }

  document.getElementById('updated-label').textContent =
    rs.session.status === 'REPLAY'
      ? `${fmtDuration(replay.elapsedMs)} elapsed`
      : 'Updated ' + new Date().toLocaleTimeString();
}

function renderTimingTower() {
  // Recompute tyre age on every render so it advances with currentLap,
  // not only when new stint records happen to arrive.
  for (const [n, s] of Object.entries(rs.stints)) {
    const d = rs.drivers[n];
    if (d) {
      const start = d.tyre.lapStart || s.lap_start || 1;
      d.tyre.age = Math.max(0, (d.currentLap || rs.lapMax || start) - start);
    }
  }
  const allDrivers = Object.values(rs.drivers).filter(d => d.acronym);
  if (!allDrivers.length) {
    document.getElementById('timing-rows').innerHTML =
      '<p class="px-2 py-3 text-sm" style="color:var(--text-muted)">No driver data â€” the OpenF1 API returned no records for this session.</p>';
    document.getElementById('timing-note').style.display = 'none';
    return;
  }

  // Pre/post-race or no-gap-data banner
  const noteEl = document.getElementById('timing-note');
  const anyNumericGap = allDrivers.some(d => typeof d.gapToLeader === 'number');
  if (!anyNumericGap && allDrivers.length >= 10) {
    const pct = replay.durationMs ? replay.elapsedMs / replay.durationMs : 0;
    const hasChequered = rs.raceControl.some(m =>
      (m.flag || '').toUpperCase() === 'CHEQUERED' ||
      (m.message || '').toUpperCase().includes('CHEQUERED'));
    let note = '';
    if (rs.session.status === 'REPLAY' && pct < 0.08)
      note = 'Pre-race / formation lap â€” gap data will appear after race start';
    else if (rs.session.status === 'REPLAY' && pct > 0.88 && hasChequered)
      note = 'Race finished â€” showing final order';
    else
      note = 'Gap data not available for this session â€” order shown by driver number';
    noteEl.textContent = note;
    noteEl.style.display = '';
  } else {
    noteEl.style.display = 'none';
  }

  // If the /position endpoint has no data, derive positions from gap_to_leader.
  const anyPosKnown = allDrivers.some(d => d.position !== null);
  const anyGapKnown = allDrivers.some(d => typeof d.gapToLeader === 'number');
  if (!anyPosKnown && anyGapKnown) {
    [...allDrivers]
      .sort((a, b) => {
        const an = typeof a.gapToLeader === 'number';
        const bn = typeof b.gapToLeader === 'number';
        if (an && bn) return a.gapToLeader - b.gapToLeader;
        if (an) return -1; if (bn) return 1;
        return a.number - b.number;
      })
      .forEach((d, i) => { d._derivedPos = i + 1; });
  } else {
    allDrivers.forEach(d => { d._derivedPos = null; });
  }
  const effPos = d => d._derivedPos ?? d.position;

  const drivers = allDrivers
    .sort((a, b) => {
      const ap = effPos(a), bp = effPos(b);
      if (ap !== null && bp !== null) return ap - bp;
      if (ap !== null) return -1;
      if (bp !== null) return 1;
      return a.number - b.number;
    });
  document.getElementById('timing-rows').innerHTML = drivers.map((d, i) => {
    const bg  = i % 2 ? 'var(--bg-surface2)' : 'var(--bg-surface)';
    const dim = (d.status === 'OUT' || d.status === 'DNF') ? 'opacity:.45;' : '';
    const statusLbl = (d.status === 'OUT' || d.status === 'DNF')
      ? `<span class="text-xs px-1 rounded" style="background:#333;color:var(--red)">${d.status}</span>` : '';
    const dp = effPos(d);
    return `
      <div class="grid items-center px-2 py-1.5 text-sm"
           style="background:${bg};${dim}border-left:3px solid ${d.teamColour};
                  grid-template-columns:2rem 3.5rem 2rem 2.2rem 3rem 5.5rem 5.5rem 6rem 2rem">
        <span class="text-center text-xs font-bold ${posClass(dp)}">${dp ?? 'â€”'}</span>
        <span class="font-bold truncate">${escapeHtml(d.acronym)}${statusLbl}</span>
        <span class="text-center"><span class="${tyreClass(d.tyre.compound)}">${d.tyre.compound ? tyreLabel(d.tyre.compound) : 'â€”'}</span></span>
        <span class="text-right text-xs" style="color:var(--text-muted)">${d.tyre.age || 'â€”'}</span>
        <span class="text-right text-xs tabular-nums" style="color:var(--text-muted)">${d.currentLap ?? 'â€”'}</span>
        <span class="text-right text-xs tabular-nums"
              style="color:${dp===1?'var(--green)':'var(--text-primary)'}">${escapeHtml(fmtGap(d.gapToLeader))}</span>
        <span class="text-right text-xs tabular-nums" style="color:var(--text-muted)">${escapeHtml(d.interval!=null?fmtGap(d.interval):'â€”')}</span>
        <span class="text-right text-xs tabular-nums">${escapeHtml(fmtLapTime(d.lastLapTime))}</span>
        <span class="text-center text-xs" style="color:var(--text-muted)">${d.pitCount || ''}</span>
      </div>`;
  }).join('');
}

function renderRaceControl() {
  const feed = document.getElementById('rc-feed');
  if (!rs.raceControl.length) {
    const msg = replay.raw.race_control && replay.raw.race_control.length === 0
      ? 'Race control data not available for this session.'
      : 'No messages yet.';
    feed.innerHTML = `<p class="p-1" style="color:var(--text-muted)">${msg}</p>`;
    return;
  }

  // Apply filter
  let msgs = rs.raceControl;
  if (rcFilter === 'flags') {
    msgs = msgs.filter(m => {
      const f = (m.flag || '').toUpperCase();
      return f && f !== '' && !['BLUE', 'DRS'].includes(f);
    });
  } else if (rcFilter === 'sc') {
    msgs = msgs.filter(m => {
      const t = ((m.flag || '') + ' ' + (m.message || '')).toUpperCase();
      return t.includes('SAFETY CAR') || t.includes('VSC') || t.includes('VIRTUAL SAFETY');
    });
  } else if (rcFilter === 'drs') {
    msgs = msgs.filter(m => (m.message || '').toUpperCase().includes('DRS'));
  }

  if (!msgs.length) {
    feed.innerHTML = '<p class="p-1" style="color:var(--text-muted)">No messages match this filter.</p>';
    return;
  }

  feed.innerHTML = msgs.map(m => {
    const badge = m.category
      ? `<span class="rounded px-1" style="background:#333;color:#aaa">${escapeHtml(m.category)}</span> ` : '';
    return `
      <div class="rounded px-2 py-1.5 ${rcBorderClass(m)}" style="background:var(--bg-surface2)">
        <div class="mb-0.5" style="color:var(--text-muted)">${escapeHtml(m.date ? new Date(m.date).toLocaleTimeString() : '')}</div>
        <div>${badge}${escapeHtml(m.message)}</div>
      </div>`;
  }).join('');
}

function renderWeather() {
  const w = rs.weather, D = 'â€”';
  const noData = replay.raw.weather && replay.raw.weather.length === 0;
  document.getElementById('wx-track').textContent    = noData ? 'Weather: no data' : `Track ${w.trackTemp   != null ? w.trackTemp+'Â°C'  : D}`;
  document.getElementById('wx-air').textContent      = noData ? '' : `Air ${w.airTemp      != null ? w.airTemp+'Â°C'    : D}`;
  document.getElementById('wx-humidity').textContent = noData ? '' : `Humidity ${w.humidity  != null ? w.humidity+'%'    : D}`;
  document.getElementById('wx-wind').textContent     = noData ? '' : `Wind ${w.windSpeed   != null ? w.windSpeed+' m/s' : D}`;
  document.getElementById('wx-rain').textContent     = noData ? '' : `Rain ${w.rainfall ? 'YES' : (w.rainfall === 0 ? 'No' : D)}`;
}

function renderAll() {
  renderStatusIndicator();
  renderHeader();
  renderTimingTower();
  renderRaceControl();
  renderWeather();
}

// â”€â”€ Copy standings â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function copyStandings() {
  const all = Object.values(rs.drivers).filter(d => d.acronym);
  if (!all.length) return;
  const anyPosKnown = all.some(d => d.position !== null);
  const anyGapKnown = all.some(d => typeof d.gapToLeader === 'number');
  if (!anyPosKnown && anyGapKnown) {
    [...all].sort((a, b) => {
      const an = typeof a.gapToLeader === 'number', bn = typeof b.gapToLeader === 'number';
      if (an && bn) return a.gapToLeader - b.gapToLeader;
      if (an) return -1; if (bn) return 1; return a.number - b.number;
    }).forEach((d, i) => { d._derivedPos = i + 1; });
  }
  const effPos = d => d._derivedPos ?? d.position;
  const drivers = all.sort((a, b) => {
    const ap = effPos(a), bp = effPos(b);
    if (ap !== null && bp !== null) return ap - bp;
    if (ap !== null) return -1; if (bp !== null) return 1;
    return a.number - b.number;
  });
  const text = [
    '| P  | Driver | Gap      | Tyre | Age |',
    '|----|--------|----------|------|-----|',
    ...drivers.map(d =>
      `| ${String(effPos(d) ?? 'â€”').padEnd(2)} | ${d.acronym.padEnd(6)} | ${fmtGap(d.gapToLeader).padEnd(8)} | ${(d.tyre.compound ? tyreLabel(d.tyre.compound) : 'â€”').padEnd(4)} | ${String(d.tyre.age || 'â€”').padEnd(3)} |`
    ),
  ].join('\n');
  const btn = document.getElementById('copy-btn');
  navigator.clipboard.writeText(text)
    .then(() => { btn.textContent = 'Copied!'; setTimeout(() => btn.textContent = 'Copy', 2000); })
    .catch(() => { btn.textContent = 'Failed';  setTimeout(() => btn.textContent = 'Copy', 2000); });
}

// â”€â”€ Panel helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function showMain()  { document.getElementById('main-content').style.display = ''; document.getElementById('idle-panel').style.display = 'none'; }
function showIdle()  { document.getElementById('idle-panel').style.display = '';   document.getElementById('main-content').style.display = 'none'; }
function showReplayBar() { document.getElementById('replay-bar').style.display = ''; }
function hideReplayBar() { document.getElementById('replay-bar').style.display = 'none'; }

// â”€â”€ Batch load a full session â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async function loadAllForSession(sessionKey) {
  document.getElementById('session-label').textContent = 'Loading sessionâ€¦';
  const sessions = await apiFetch('sessions', { session_key: sessionKey }).catch(() => []);
  if (sessions.length) {
    const s = sessions[0];
    rs.session.name    = s.session_name || s.session_type || 'Race';
    rs.session.circuit = s.circuit_short_name || s.location || '';
    rs.session.key     = sessionKey;
  }
  const [drv, ivl, pos, lps, stts, pit, rc, wx] = await Promise.allSettled([
    apiFetch('drivers',      { session_key: sessionKey }),
    apiFetch('intervals',    { session_key: sessionKey }),
    apiFetch('position',     { session_key: sessionKey }),
    apiFetch('laps',         { session_key: sessionKey }),
    apiFetch('stints',       { session_key: sessionKey }),
    apiFetch('pit',          { session_key: sessionKey }),
    apiFetch('race_control', { session_key: sessionKey }),
    apiFetch('weather',      { session_key: sessionKey }),
  ]);
  if (drv.status  === 'fulfilled') mergeDrivers(drv.value);
  if (lps.status  === 'fulfilled') mergeLaps(lps.value);
  if (ivl.status  === 'fulfilled') mergeIntervals(ivl.value);
  if (pos.status  === 'fulfilled') mergePositions(pos.value);
  if (stts.status === 'fulfilled') mergeStints(stts.value);
  if (pit.status  === 'fulfilled') mergePits(pit.value);
  if (rc.status   === 'fulfilled') mergeRaceControl(rc.value);
  if (wx.status   === 'fulfilled') mergeWeather(wx.value);
  // Scan full race_control for total_laps (CHEQUERED may be beyond the 150-message display cap)
  if (!rs.session.totalLaps && rc.status === 'fulfilled') {
    for (const m of rc.value) {
      if (m.message && m.message.toUpperCase().includes('CHEQUERED') && m.lap_number) {
        rs.session.totalLaps = m.lap_number;
        break;
      }
    }
  }
}

// â”€â”€ Session state machine â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let _masterTicker   = null;
let _idleInterval   = null;
let _countdownTimer = null;
let _nextRaceDate   = null;
const _pollerNextAt = {};

function transitionTo(status) {
  rs.session.status = status;
  if (status === 'LIVE') {
    clearInterval(_idleInterval); clearInterval(_countdownTimer);
    startPolling();
    showMain();
  } else if (status === 'FINISHED') {
    stopPolling();
    showMain();
  } else if (status === 'IDLE') {
    stopPolling();
    showIdle();
    _loadIdleData();
    _idleInterval = setInterval(detectSession, 5 * 60 * 1000);
  } else if (status === 'ERROR') {
    stopPolling();
  } else if (status === 'REPLAY') {
    showMain(); showReplayBar();
  }
  renderStatusIndicator();
}

// â”€â”€ Session detection â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async function detectSession() {
  try {
    const sessions = await apiFetch('sessions', { session_key: 'latest' });
    if (!sessions.length) { transitionTo('IDLE'); return; }
    const s = sessions[0];
    const now = Date.now(), dateEnd = new Date(s.date_end).getTime();
    const minsAgo = (now - dateEnd) / 60000;
    if (dateEnd > now || minsAgo < 30) {
      rs.session.key = s.session_key;
      rs.session.name = s.session_name || s.session_type;
      rs.session.circuit = s.circuit_short_name || s.location || '';
      await loadAllForSession(s.session_key);
      persistUrl();
      transitionTo(dateEnd > now ? 'LIVE' : 'FINISHED');
    } else {
      transitionTo('IDLE');
    }
  } catch (err) {
    rs.errors.session = err.message;
    transitionTo('ERROR');
    // err.message is "NNN: detail" â€” show just the detail part
    document.getElementById('session-label').textContent = 'API error: ' + (err.message.replace(/^\d{3}: /, '') || err.message);
  }
}

// â”€â”€ Polling scheduler â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function startPolling() {
  if (_masterTicker) return;
  for (const k of Object.keys(POLL_CFG)) _pollerNextAt[k] = 0;
  _masterTicker = setInterval(_runPollers, 5000);
}
function stopPolling() {
  if (_masterTicker) { clearInterval(_masterTicker); _masterTicker = null; }
}

const _mergeFns = {
  intervals: mergeIntervals, position: mergePositions, race_control: mergeRaceControl,
  pit: mergePits, stints: mergeStints, laps: mergeLaps, weather: mergeWeather,
};

async function _runPollers() {
  const now = Date.now();
  for (const [name, cfg] of Object.entries(POLL_CFG)) {
    if (now < (_pollerNextAt[name] || 0)) continue;
    _pollerNextAt[name] = now + cfg.ms;
    try {
      const data = await fetchIncremental(name);
      _mergeFns[name](data);
      rs.errors[name] = null;
      renderAll();
      if (name === 'race_control') _checkChequeredFlag();
    } catch (err) {
      rs.errors[name] = err.message;
      if (err.message.startsWith('429') || err.message.startsWith('503'))
        _pollerNextAt[name] = now + Math.min(cfg.ms * 2, 300000);
    }
  }
}

function _checkChequeredFlag() {
  if (rs.session.status !== 'LIVE') return;
  if (rs.raceControl.some(m => (m.message || '').toUpperCase().includes('CHEQUERED')))
    transitionTo('FINISHED');
}

// â”€â”€ IDLE: next race + last race â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async function _loadIdleData() {
  const year = new Date().getFullYear();
  try {
    const allSessions = await apiFetch('sessions', { session_type: 'Race', year });
    const now = new Date();
    const future = allSessions.filter(s => new Date(s.date_start) > now)
                              .sort((a, b) => a.date_start.localeCompare(b.date_start));
    let past   = allSessions.filter(s => new Date(s.date_end)   < now)
                            .sort((a, b) => b.date_end.localeCompare(a.date_end));
    // If no past races this year yet (e.g. pre-season), look at the previous year
    if (!past.length) {
      const prevSessions = await apiFetch('sessions', { session_type: 'Race', year: year - 1 });
      past = prevSessions.filter(s => new Date(s.date_end) < now)
                         .sort((a, b) => b.date_end.localeCompare(a.date_end));
    }

    if (future.length) {
      const n = future[0];
      _nextRaceDate = new Date(n.date_start);
      document.getElementById('next-race-name').textContent    = (n.country_name || '') + ' Grand Prix';
      document.getElementById('next-race-circuit').textContent = n.circuit_short_name || n.location || '';
      document.getElementById('next-race-date').textContent    = _nextRaceDate.toLocaleString();
      clearInterval(_countdownTimer);
      _countdownTimer = setInterval(_updateCountdown, 1000);
      _updateCountdown();
    }

    if (past.length) {
      const lastKey = past[0].session_key;
      const lastDrv = await apiFetch('drivers', { session_key: lastKey });
      const lastPos = await apiFetch('position', { session_key: lastKey });
      const drvMap  = Object.fromEntries(lastDrv.map(d => [d.driver_number, d]));
      const latest  = {};
      for (const r of lastPos) {
        if (!latest[r.driver_number] || r.date > latest[r.driver_number].date)
          latest[r.driver_number] = r;
      }
      const top3 = Object.values(latest).sort((a, b) => a.position - b.position).slice(0, 3);
      const podiumEl = document.getElementById('last-race-podium');
      const medals   = ['ðŸ¥‡', 'ðŸ¥ˆ', 'ðŸ¥‰'];
      podiumEl.innerHTML = top3.map((r, i) => {
        const d = drvMap[r.driver_number] || {};
        return `<div class="text-center"><div class="text-lg">${medals[i]}</div>
          <div class="font-bold text-sm">${escapeHtml(d.name_acronym || '?')}</div>
          <div class="text-xs" style="color:var(--text-muted)">${escapeHtml(d.team_name || '')}</div>
        </div>`;
      }).join('');
      document.getElementById('last-race-block').style.display = '';
    }
  } catch (err) {
    document.getElementById('next-race-name').textContent = 'Could not load schedule';
  }
}

function _updateCountdown() {
  if (!_nextRaceDate) return;
  const diff = _nextRaceDate - new Date();
  if (diff <= 0) {
    document.getElementById('countdown').textContent = 'Starting now!';
    detectSession();
    return;
  }
  const d = Math.floor(diff / 86400000);
  const h = Math.floor((diff % 86400000) / 3600000);
  const m = Math.floor((diff % 3600000) / 60000);
  const s = Math.floor((diff % 60000) / 1000);
  document.getElementById('countdown').textContent =
    d > 0
      ? `${d}d ${String(h).padStart(2,'0')}:${String(m).padStart(2,'0')}:${String(s).padStart(2,'0')}`
      : `${String(h).padStart(2,'0')}:${String(m).padStart(2,'0')}:${String(s).padStart(2,'0')}`;
}

// â”€â”€ Replay mode â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const replay = {
  raw:           {},   // endpoint â†’ sorted array
  ptr:           {},   // endpoint â†’ index
  driversRaw:    [],
  datelessStints:[],   // stints without a date field, re-applied after seeks
  t0:            0,    // epoch ms of first event
  durationMs:    0,
  elapsedMs:     0,
  speed:         1,
  ticker:        null,
};
const REPLAY_EPS = ['intervals', 'position', 'laps', 'stints', 'pit', 'race_control', 'weather'];

async function startReplay(sessionKey, speed) {
  replay.speed = speed || 1;
  document.getElementById('session-label').textContent = 'Loading replayâ€¦';
  rs.session.status = 'REPLAY';

  const [drv, ivl, pos, lps, stts, pit, rc, wx] = await Promise.allSettled([
    apiFetch('drivers',      { session_key: sessionKey }),
    apiFetch('intervals',    { session_key: sessionKey }),
    apiFetch('position',     { session_key: sessionKey }),
    apiFetch('laps',         { session_key: sessionKey }),
    apiFetch('stints',       { session_key: sessionKey }),
    apiFetch('pit',          { session_key: sessionKey }),
    apiFetch('race_control', { session_key: sessionKey }),
    apiFetch('weather',      { session_key: sessionKey }),
  ]);

  // Only hard-abort when every endpoint failed â€” that signals a network or auth
  // problem, not just a session that lacks certain data types.  Individual
  // failures (position missing for qualifying, weather not available, etc.)
  // fall back to [] below and the allDates guard later catches truly empty sessions.
  const allEndpoints = [drv, ivl, pos, lps, stts, pit, rc, wx];
  if (allEndpoints.every(r => r.status === 'rejected')) {
    const first = allEndpoints[0];
    const msg = first.reason?.message || 'unknown error';
    const code = msg.match(/^(\d{3})/)?.[1];
    const hint = code === '401' ? 'Unauthorized â€” the API rejected the request.'
               : code === '403' ? 'Session in progress â€” replay is only available for completed sessions.'
               : code === '404' ? 'Session not found â€” check the session key.'
               : code === '429' ? 'Rate limited â€” wait a moment and try again.'
               : msg;
    document.getElementById('session-label').textContent = code ? `API error: ${hint}` : hint;
    rs.session.status = 'ERROR';
    hideReplayBar();
    renderStatusIndicator();
    return;
  }

  replay.driversRaw = drv.status === 'fulfilled' ? drv.value : [];
  mergeDrivers(replay.driversRaw);

  const raws = [ivl, pos, lps, stts, pit, rc, wx];
  REPLAY_EPS.forEach((ep, i) => {
    const r = raws[i];
    replay.raw[ep] = r.status === 'fulfilled'
      ? r.value.filter(x => x.date).sort((a, b) => a.date < b.date ? -1 : 1)
      : [];
    replay.ptr[ep] = 0;
  });
  // Feed dateless stints up front (and cache them for seekReplay)
  replay.datelessStints = stts.status === 'fulfilled' ? stts.value.filter(s => !s.date) : [];
  if (replay.datelessStints.length) mergeStints(replay.datelessStints);

  const allDates = Object.values(replay.raw).flat().map(x => x.date).filter(Boolean).sort();
  if (!allDates.length) {
    document.getElementById('session-label').textContent = `No timing data for session ${sessionKey} â€” try a Race or Sprint session key.`;
    rs.session.status = 'ERROR';
    hideReplayBar();
    renderStatusIndicator();
    return;
  }
  replay.t0         = new Date(allDates[0]).getTime();
  replay.durationMs = new Date(allDates[allDates.length - 1]).getTime() - replay.t0;
  replay.elapsedMs  = 0;

  const meta = await apiFetch('sessions', { session_key: sessionKey }).catch(() => []);
  if (meta.length) {
    rs.session.name    = meta[0].session_name || meta[0].session_type || '';
    rs.session.circuit = meta[0].circuit_short_name || meta[0].location || '';
    rs.session.key     = sessionKey;
  }

  // Extract total laps â€” try sources in priority order:
  // 1. CHEQUERED flag race_control message (most explicit)
  // 2. Max lap_number in /laps data (reliable for sessions with lap data)
  // 3. Max lap_end in /stints data (completed stints always carry this)
  if (!rs.session.totalLaps && rc.status === 'fulfilled') {
    for (const m of rc.value) {
      if (m.message && m.message.toUpperCase().includes('CHEQUERED') && m.lap_number) {
        rs.session.totalLaps = m.lap_number;
        break;
      }
    }
  }
  if (!rs.session.totalLaps && lps.status === 'fulfilled') {
    let max = 0;
    for (const r of lps.value) { if (r.lap_number > max) max = r.lap_number; }
    if (max) rs.session.totalLaps = max;
  }
  if (!rs.session.totalLaps && stts.status === 'fulfilled') {
    let max = 0;
    for (const r of stts.value) { if (r.lap_end > max) max = r.lap_end; }
    if (max) rs.session.totalLaps = max;
  }

  document.getElementById('replay-duration').textContent = fmtDuration(replay.durationMs);
  showMain(); showReplayBar();
  updateSpeedButtons(replay.speed);
  _startReplayTicker();
  renderAll();
}

function _startReplayTicker() {
  if (replay.ticker) clearInterval(replay.ticker);
  replay.ticker = setInterval(_replayTick, 1000);
}

function _replayTick() {
  replay.elapsedMs = Math.min(replay.elapsedMs + 1000 * replay.speed, replay.durationMs);
  _feedReplayUpTo(new Date(replay.t0 + replay.elapsedMs).toISOString());

  const pct = replay.durationMs ? replay.elapsedMs / replay.durationMs : 0;
  document.getElementById('replay-scrubber').value = Math.round(pct * 1000);
  document.getElementById('replay-elapsed').textContent = fmtDuration(replay.elapsedMs);
  document.getElementById('replay-status').textContent  = '';

  if (replay.elapsedMs >= replay.durationMs) {
    clearInterval(replay.ticker); replay.ticker = null;
    document.getElementById('replay-status').textContent = 'â€” Finished';
  }
  renderAll();
}

function _feedReplayUpTo(simDate) {
  for (const ep of REPLAY_EPS) {
    const batch = [];
    while (replay.ptr[ep] < replay.raw[ep].length &&
           replay.raw[ep][replay.ptr[ep]].date <= simDate)
      batch.push(replay.raw[ep][replay.ptr[ep]++]);
    if (batch.length) _mergeFns[ep](batch);
  }
}

// Seek: drag scrubber or call seekReplay(0..1) to jump to any race moment
function seekReplay(pct) {
  if (!replay.durationMs) return;
  if (replay.ticker) { clearInterval(replay.ticker); replay.ticker = null; }

  // Reset dynamic driver state
  for (const d of Object.values(rs.drivers)) {
    d.position = null; d.gapToLeader = null; d.interval = null;
    d.lastLapTime = null; d.currentLap = null;
    d.tyre = { compound: '', age: 0, stintNumber: 0, lapStart: 1 };
    d.pitCount = 0; d.lastPitLap = null; d._pitLaps = new Set();
    d.status = 'RACING';
  }
  rs.lapMax = 0; rs.raceControl = []; rs.weather = {}; rs.stints = {};

  mergeDrivers(replay.driversRaw);
  // Re-apply dateless stints so tyres are populated even after a seek
  if (replay.datelessStints && replay.datelessStints.length)
    mergeStints(replay.datelessStints);
  for (const ep of REPLAY_EPS) replay.ptr[ep] = 0;

  replay.elapsedMs = pct * replay.durationMs;
  _feedReplayUpTo(new Date(replay.t0 + replay.elapsedMs).toISOString());

  document.getElementById('replay-elapsed').textContent = fmtDuration(replay.elapsedMs);
  document.getElementById('replay-scrubber').value = Math.round(pct * 1000);
  renderAll();
  if (replay.elapsedMs < replay.durationMs) _startReplayTicker();
}

// Expose to speed buttons
function setReplaySpeed(s) {
  replay.speed = s;
  updateSpeedButtons(s);
  _startReplayTicker(); // restart so new speed takes effect immediately
}

function updateSpeedButtons(active) {
  document.querySelectorAll('.speed-btn[data-speed]').forEach(btn => {
    btn.classList.toggle('active', parseInt(btn.dataset.speed) === active);
  });
}

// Wire up scrubber drag
document.getElementById('replay-scrubber').addEventListener('input', e => {
  seekReplay(parseInt(e.target.value) / 1000);
});

// â”€â”€ Init â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async function init() {
  readUrlParams();

  if (rs.session.status === 'REPLAY' && _replayKey) {
    transitionTo('REPLAY');
    await startReplay(_replayKey, _replaySpeed);
    return;
  }
  if (rs.session.key) {
    showMain();
    await loadAllForSession(rs.session.key);
    // Determine if this session is live, finished, or historical
    const sessions = await apiFetch('sessions', { session_key: rs.session.key }).catch(() => []);
    if (sessions.length) {
      const s = sessions[0];
      const dateEnd = new Date(s.date_end).getTime();
      const minsAgo = (Date.now() - dateEnd) / 60000;
      if (dateEnd > Date.now()) transitionTo('LIVE');
      else if (minsAgo < 30)   transitionTo('FINISHED');
      else                     { rs.session.status = 'FINISHED'; renderAll(); }
    } else {
      rs.session.status = 'FINISHED';
      renderAll();
    }
    persistUrl();
    return;
  }
  // No params: detect live/idle
  await detectSession();
}

init();
</script>
</body>
</html>
